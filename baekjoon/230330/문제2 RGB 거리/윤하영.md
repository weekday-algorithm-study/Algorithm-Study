## 문제 설명

---

RGB거리에는 집이 N개 있다. 거리는 선분으로 나타낼 수 있고, 1번 집부터 N번 집이 순서대로 있다.

집은 빨강, 초록, 파랑 중 하나의 색으로 칠해야 한다. 각각의 집을 빨강, 초록, 파랑으로 칠하는 비용이 주어졌을 때, 아래 규칙을 만족하면서 모든 집을 칠하는 비용의 최솟값을 구해보자.

- 1번 집의 색은 2번 집의 색과 같지 않아야 한다.
- N번 집의 색은 N-1번 집의 색과 같지 않아야 한다.
- i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다.

## 접근 방식

---

R = 0 / G = 1 / B = 2

i-1번 집의 색은 i번 집의 색에 영향을 주므로 house[i][j]라는 DP 테이블을 구현하여 i번째 집의 색이 j일 때의 최소 비용을 구하고자 한다.

## 문제 풀이

---

```cpp
#include <iostream>
#include <algorithm> // min함수 

using namespace std;

int N;
int house[1001][3]; // DP테이블. house[i][j] = i번째 집의 색이 j일때의 최소비용 .
int cost[3]; // 비용

int main() {
	cin >> N;

	house[0][0] = 0;
	house[0][1] = 0;
	house[0][2] = 0;
	
for (int i = 1; i <= N; i++) // 집은 1번부터 시작한다.
	{
		cin >> cost[0] >> cost[1] >> cost[2]; // RGB의 비용을 받아와 R=0 G=1 B=2에 저장한다.
		house[i][0] = cost[0] + min(house[i - 1][1], house[i - 1][2]); // ---------------------------------------------- //
		house[i][1] = cost[1] + min(house[i - 1][0], house[i - 1][2]); // 이전의 집의 색에서 더 작은 비용을 가져온다
		house[i][2] = cost[2] + min(house[i - 1][0], house[i - 1][1]); // ---------------------------------------------- //
	}
	
	cout << min(house[N][0], min(house[N][1], house[N][2])); // house[N]의 RGB중 가장 작은 비용을 출력한다.
	return 0;
}
```

## 시간 복잡도

---

DP는 공간복잡도를 늘리는 대신 시간복잡도를 줄이는 알고리즘이다. for문을 돌며 한 번의 변수를 한번만 참조하므로 시간복잡도는 O(N)인 것 같다.

## 공간 복잡도

---

DP테이블의 구현에 필요한 house 변수가 공간복잡도에 가장 큰 영향을 줄 것 같다. 

## 어려웠던 부분 & 해결 과정

---

처음에는 최소비용 탐색, 음의 자연수가 없는 점 때문에 이 문제를 다익스트라 알고리즘으로 판단했다. 

하지만 하나의 노드가 가질 수 있는 비용이 3가지라는 부분을 고려하지 못했다. 3가지 비용 중 어떤 것을 선택하느냐에 따라 최소비용이 유기적으로 변화하기 때문에 DP로 풀어야 했던 문제다.