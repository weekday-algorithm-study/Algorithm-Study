## 문제 설명

---

KOI 부설 과학연구소에서는 많은 종류의 산성 용액과 알칼리성 용액을 보유하고 있다. 각 용액에는 그 용액의 특성을 나타내는 하나의 정수가 주어져있다.  산성 용액의 특성값은 1부터 1,000,000,000까지의 양의 정수로 나타내고, 알칼리성 용액의 특성값은 -1부터 -1,000,000,000까지의 음의 정수로 나타낸다.

같은 양의 세 가지 용액을 혼합한 용액의 특성값은 혼합에 사용된 각 용액의 특성값의 합으로 정의한다. 이 연구소에서는 같은 양의 세 가지 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들려고 한다.

예를 들어, 주어진 용액들의 특성값이 [-2, 6, -97, -6, 98]인 경우에는 특성값이 -97와 -2인 용액과 특성값이 98인 용액을 혼합하면 특성값이 -1인 용액을 만들 수 있고, 이 용액이 특성값이 0에 가장 가까운 용액이다. 참고로, 세 종류의 알칼리성 용액만으로나 혹은 세 종류의 산성 용액만으로 특성값이 0에 가장 가까운 혼합 용액을 만드는 경우도 존재할 수 있다.

산성 용액과 알칼리성 용액이 주어졌을 때, 이 중 같은 양의 세 개의 서로 다른 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들어내는 세 용액을 찾는 프로그램을 작성하시오.

## 접근 방식

---

받아온 용액을 오름차순으로 정렬하면 0보다 큰지 작은지에 따라 값을 한번씩만 조정하면 되므로 0에 가까운 값을 구하기 용이하다. 남은 것은 합을 구하는 알고리즘이다.

세 용액의 합이라는 이야기를 확인했을 때 슬라이딩 윈도우를 떠올렸다. 하지만 연속된 세가지의 합은 아니므로 투 포인터 알고리즘을 사용한다.

요구하는 용액은 2개가 아니므로 포인터로 가리킬 두가지 값 이외의 하나의 변수가 추가적으로 필요하다. 포인터가 탐색하는 동안 고정된 값을 가지고 있을 변수를 num으로 정해주었다.

## 문제 풀이

---

```cpp
#include <iostream>
#include <vector>
#include <algorithm> // sort 함수

using namespace std;

int N; // N의 최대치는 5000이므로 int로 선언.
long long small = 3000000000+1; // 용액의 특성값 최대치 1,000,000,000가 3번 중복될 수 있으므로 최대치인 3,000,000,000 + 1로 초기화
vector<long long> answer(3); // 최소값을 만드는 용액의 특성 3개를 저장할 vector 변수. 특성값 최대치는 1,000,000,000이므로 long long으로 선언.

int main(void)
{
	cin >> N;

	vector<long long> liquid(N); // 주어지는 용액의 특성값을 저장할 vector 변수. 특성값이므로 long long
	for (int i = 0; i < N; i++) // N까지 반복할 i는 int로 선언해도 괜찮음
	{
		cin >> liquid[i];
	}
	sort(liquid.begin(), liquid.end()); // 받아온 용액의 특성값을 오름차순으로 정렬

	// ---------------------------------------------------------------------------------------
	// 
	// 오름차순으로 정렬된 용액의 배열에서 가장 작은 i를 첫번째 num으로 지정
	// num은 고정시킨 상태로 left와 right 두개의 포인터를 움직여 최소값을 탐색할것임
	// 
	// ---------------------------------------------------------------------------------------

	for (int i = 0; i < N; i++) {
		int num = i; // left와 right를 조정하는 동안 고정된 값을 가지고 있을 num
		int left = i; // 항상 배열의 가장 왼쪽 값을 배열을 left 포인터로 초기화
		int right = N - 1; // 항상 배열의 가장 오른쪽 값을 right 포인터로 초기화
		
		while (left != right)
		{
			if (left == i) { left++; continue; } // 만약 left가 num과 같은 상태라면 아래 과정을 스킵하고 다음으로 넘김
			if (right == i) { right--; continue; } // 만약 right가 num과 같은 상태라면 아래 과정을 스킵하고 다음으로 넘김

			long long sum = liquid[left] + liquid[right] + liquid[num]; // 세 용액의 합

			if (abs(sum) < small) // 음수가 존재하며, 0에 가장 가까운 값을 찾고 있으므로 절대값(abs)으로 비교해야함
			{								// 만약 sum의 절대값이 지금 가지고 있는 최소값보다 더 작다면
				small = abs(sum);			// 지금 가지고 있는 최소값을 sum의 절대값으로 변경
				answer[0] = liquid[num];	// answer의 3가지 용액을 현재의 sum을 만든 용액 3개로 변경
				answer[1] = liquid[left];
				answer[2] = liquid[right];
			}
			if (sum == 0) break;			// sum이 0이면 더이상 탐색할 필요가 없음
			if (sum > 0) right--;			// sum이 크다면 값을 줄일 필요가 있음. right를 줄여줌.
			if (sum < 0) left++;			// sum이 작다면 값을 키울 필요가 있음. left를 줄여줌.
		}
	}

	cout << answer[0] << " " << answer[1] << " " << answer[2];
	
	return 0;
}
```

## 시간 복잡도

---

투 포인터 알고리즘과 이분탐색을 이용한 이중반복을 돌리므로 O(n^2) 인 것 같다.

## 공간 복잡도

---

int값의 범위는 –2,147,483,648 ~ 2,147,483,647이다. 이는 용액 특성합 최대치인 3,000,000,000보다 작으므로 long long 변수를 사용한다. 

그리고는 잘 모르겠다…

## 어려웠던 부분 & 해결 과정

---

<aside>
💡 **[입력]**

5

-5 -1 2 3 4

**[정답]**

-5 2 3

**[출력]**

-1 2 3

</aside>

처음에는 투 포인터 알고리즘에 이분탐색을 사용하면 된다고 생각해서 3번째 변수를 mid 변수로 정하고 단일반복을 돌렸다. 그랬더니 해당 반례에서 정답인 -5를 제외하는 오류가 발생했다.

처음 탐색할 때 -5는 정답이 아니었지만 전체를 보았을 때는 -5가 들어가는 숫자가 정답이다. 이럴 경우 제외된 변수(예시의 경우 -5)를 다시 가지고 와야 하는데 그 방법을 몰라서 오랫동안 고민했다.

이분탐색이라는 고정관념이 문제였다. left와 right값에 영향을 받는 mid 변수가 아닌 일정하게 전체를 탐색하는 num 변수를 정해두고 이중반복으로 left와 right값을 조절하는 것으로 문제를 해결했다.

이중반복문의 조건을 조정할 때 가장 많은 실수를 했던 것 같다.