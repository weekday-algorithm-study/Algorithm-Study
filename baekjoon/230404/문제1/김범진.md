# 문제
유현이가 새 집으로 이사했다. 새 집의 크기는 N×N의 격자판으로 나타낼 수 있고, 1×1크기의 정사각형 칸으로 나누어져 있다. 각각의 칸은 (r, c)로 나타낼 수 있다. 여기서 r은 행의 번호, c는 열의 번호이고, 행과 열의 번호는 1부터 시작한다. 각각의 칸은 빈 칸이거나 벽이다.
오늘은 집 수리를 위해서 파이프 하나를 옮기려고 한다. 파이프는 아래와 같은 형태이고, 2개의 연속된 칸을 차지하는 크기이다.



파이프는 회전시킬 수 있으며, 아래와 같이 3가지 방향이 가능하다.



파이프는 매우 무겁기 때문에, 유현이는 파이프를 밀어서 이동시키려고 한다. 벽에는 새로운 벽지를 발랐기 때문에, 파이프가 벽을 긁으면 안 된다. 즉, 파이프는 항상 빈 칸만 차지해야 한다.

파이프를 밀 수 있는 방향은 총 3가지가 있으며, →, ↘, ↓ 방향이다. 파이프는 밀면서 회전시킬 수 있다. 회전은 45도만 회전시킬 수 있으며, 미는 방향은 오른쪽, 아래, 또는 오른쪽 아래 대각선 방향이어야 한다.

파이프가 가로로 놓여진 경우에 가능한 이동 방법은 총 2가지, 세로로 놓여진 경우에는 2가지, 대각선 방향으로 놓여진 경우에는 3가지가 있다.

아래 그림은 파이프가 놓여진 방향에 따라서 이동할 수 있는 방법을 모두 나타낸 것이고, 꼭 빈 칸이어야 하는 곳은 색으로 표시되어져 있다.


가장 처음에 파이프는 (1, 1)와 (1, 2)를 차지하고 있고, 방향은 가로이다. 파이프의 한쪽 끝을 (N, N)로 이동시키는 방법의 개수를 구해보자.

# 입력
첫째 줄에 집의 크기 N(3 ≤ N ≤ 16)이 주어진다. 둘째 줄부터 N개의 줄에는 집의 상태가 주어진다. 빈 칸은 0, 벽은 1로 주어진다. (1, 1)과 (1, 2)는 항상 빈 칸이다.

# 출력
첫째 줄에 파이프의 한쪽 끝을 (N, N)으로 이동시키는 방법의 수를 출력한다. 이동시킬 수 없는 경우에는 0을 출력한다. 방법의 수는 항상 1,000,000보다 작거나 같다.

# 해결법
dp를 이용해 해결했다. 각 가로 세로 대각선 파이프가 놓여질 수 있는 경우의 수를 dp에 기록하고 이들의 합을 통해 계산했다. list의 행과 열을 계속 헷갈려 답이 늦게 나왔다. dp나 다른 알고리즘 관련 개념은 아직 부족한 듯 하다.
# 코드
```python
'''
1. 해결법

1) 가로, 세로 대각선 파이프를 언제 놓을 수 있을까
-가로 => 이전에 설치한 파이프가 대각선 or 가로
-세로 => 이전에 설치한 파이프가 대각선 or 세로
-대각선 => 이전에 설치한 파이프 상관 x

2) 벽
벽이 주위에 있으면 파이프를 놓을 수 없다.
이 때 가로 혹은 세로는 벽으로 진로가 막혀있으면 당연히 놓을 수 없으므로 대각선만 주의
-대각선 => 나아가려는 진로와 그 위쪽, 왼쪽에 벽이 없어야 한다.

3) 알고리즘
dp를 이용해 나아가는 진로를 기록하며 해결한다.
진로를 기록하기 위해 각 가로, 세로, 대각선 파이프의 끝부분이 놓여지는 위치를 1로 둔다.
이 때 첫 가로줄에는 가로 파이프밖에 올 수 없고, 세로 줄에는 어떠한 파이프도 올 수 없으니, 이는 처음부터 만들고 간다.

'''
import sys

input = sys.stdin.readline

n = int(input())
house = [[0 for _ in range(n+1)]]
dp = [[[0 for _ in range(n+1)] for _ in range(n+1)]for _ in range(4)] # 가로=1 세로=2 대각선=3 의 배열안에 각 2차원 배열위치 ex) dp[1][2][3] => house[2][3]의 가로 파이프
for i in range(n):
    arr = [0] + list(map(int, input().split()))
    house.append(arr)
dp[1][1][2] = 1 # 처음 시작할 때 파이프는 가로이고 그 끝부분은 (1,2)
for i in range(3, n+1): # 1행은 가로파이프만 올 수 있음. 벽을 만나면 그 이후는 0
    if house[1][i] == 0: # 위에서 따로 초기화한 첫번째 상태 이후, 1이면 벽이므로 그 이후는 계산 x
        dp[1][1][i] = dp[1][1][i-1] # 1행에선 가로 파이프만 가능, 만약 (1,2)에 가로파이프가 있다면 (1,3)도 벽이 없는 이상 가로파이프가 놓여질 수 있음
        # 참고로 1열은 계산 제외 어떤 파이프도 1열로 갈 수가 없음

for i in range(2,n + 1):  # 1행은 위해서 해결 1열은 파이프 놓기 불가 즉 (2,2)부터 연산
    for j in range(2,n + 1):
        # dp에 입렵하는 수는 방법의 개수이다. 예를 들어 dp[3][1][2] 라고 하면 (1,2)로 갈 수 있는 방법의 개수
        # 대각선 파이프 추가
        if house[i][j] == 0 and house[i-1][j] == 0 and house[i][j-1] == 0:
            dp[3][i][j] = dp[1][i-1][j-1] + dp[2][i-1][j-1] + dp[3][i-1][j-1]  # 대각선 파이프는 이전 블록이 가로, 세로, 대각선 일때 놓을 수 있으므로 이전 블록의 가로, 세로 대각선 경우의 수를 전부 더한다.
        # 가로, 세로 파이프 추가
        # 두 파이프 모두 진로 방향에만 벽이 없으면 됨
        if house[i][j] == 0:
            dp[1][i][j] = dp[1][i][j-1] + dp[3][i][j-1]  # 가로 파이프는 이전 블록이 가로, 대각선일때 놓을 수 있음
            dp[2][i][j] = dp[2][i-1][j] + dp[3][i-1][j]  # 세로 파이프는 이전 블록이 세로, 대각선일때 놓을 수 있음
result = dp[1][n][n] + dp[2][n][n] + dp[3][n][n]  # (n,n)의 가로 세로 대각선 경우의 수 총 합 구하기
print(result)
```
